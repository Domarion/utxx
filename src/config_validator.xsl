<?xml version="1.0" encoding="UTF-8"?>

<!--
    This file auto-generates a class derived from util::validator that
    implements an init() method, which populates configuration options
    from the XML specification file supplied by an app developer.
     
    Copyright (c) 2012 Sergey Aleynikov <saleyn@gmail.com>
    Created: 2012-01-12
-->
     
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:output indent="yes" method="text" encoding="us-ascii"/>

<xsl:param name="now"/>
<xsl:param name="author"/>
<xsl:param name="email">saleyn@gmail.com</xsl:param>
<xsl:param name="file"/>

<!-- Setup the basic HTML skeleton -->
<xsl:template match="/config"><xsl:variable name="ifdef">
    <xsl:call-template name="def-name"/>
</xsl:variable>//------------------------------------------------------------------------------
<xsl:if test="$file">// <xsl:value-of select="$file"/></xsl:if>
// This file is auto-generated by "util/config_validator.xsl".
//
// *** DON'T MODIFY BY HAND!!! ***
//
<xsl:if test="$author">// Copyright (c) 2012 <xsl:value-of select="$author"/>
<xsl:if test="$email"> &lt;<xsl:value-of select="$email"/>&gt;</xsl:if></xsl:if>
// Created: <xsl:value-of select="$now"/>
//------------------------------------------------------------------------------

#ifndef <xsl:value-of select="$ifdef"/>
#define <xsl:value-of select="$ifdef"/>

#include &lt;util/config_validator.hpp&gt;

namespace <xsl:value-of select="@namespace"/> {
    using namespace util::config;
    using util::variant;
    using util::config::option;
    typedef option_vector ovec;
    typedef string_set    sset;
    typedef variant_set   vset;
    
    struct <xsl:value-of select="@name"/> : public validator {
        <xsl:value-of select="@name"/>() { init(); }
        
        void init() {
            clear();
            <xsl:call-template name="process_options">
                <xsl:with-param name="level">0</xsl:with-param>
                <xsl:with-param name="arg">m_options</xsl:with-param>
            </xsl:call-template>
        }
    };
} // namespace <xsl:value-of select="@namespace"/>

#endif // <xsl:value-of select="$ifdef"/><xsl:text>
</xsl:text>
</xsl:template>

<xsl:template name="process_options">
    <xsl:param name="level"/>
    <xsl:param name="arg"/>
    
    <xsl:variable name="ws"><xsl:call-template
        name="pad"><xsl:with-param name="n"><xsl:value-of
            select="$level"/></xsl:with-param></xsl:call-template></xsl:variable>

    <xsl:variable name="ws2"><xsl:call-template
        name="pad"><xsl:with-param name="n"><xsl:value-of
            select="$level+1"/></xsl:with-param></xsl:call-template></xsl:variable>

    <xsl:for-each select="option">
        <xsl:value-of select="$ws"/>{
            <xsl:value-of select="$ws"/>  ovec l_children<xsl:value-of
            select="$level"/>; sset l_names; vset l_values;
            <xsl:call-template name="process_options">
                <xsl:with-param name="level"><xsl:value-of select="$level+1"/></xsl:with-param>
                <xsl:with-param name="arg">l_children<xsl:value-of select="$level"/></xsl:with-param>
            </xsl:call-template>
            
            <xsl:for-each select="values/name">
            <xsl:value-of select="$ws2"/>l_names.insert("<xsl:value-of select="@val"/>");
            </xsl:for-each>

            <xsl:for-each select="values/value">
            <xsl:value-of select="$ws2"/>l_values.insert(variant(<xsl:call-template name="value-to-string">
                <xsl:with-param name="value"><xsl:value-of select="@val"/></xsl:with-param>
                <xsl:with-param name="type"><xsl:value-of select="../../@val_type"/></xsl:with-param>
                </xsl:call-template>));
            </xsl:for-each>

              <xsl:value-of select="$ws2"/><xsl:value-of select="$arg"/>.push_back(
            <xsl:value-of select="$ws2"/>  option("<xsl:value-of select="@name"/>", <xsl:choose>
                        <xsl:when test="@type"><xsl:call-template name="string-to-type">
                                <xsl:with-param name="type"><xsl:value-of select="@type"/></xsl:with-param>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>STRING</xsl:otherwise>
                    </xsl:choose>, <xsl:call-template name="string-to-type">
                        <xsl:with-param name="type"><xsl:value-of select="@val_type"/></xsl:with-param>
                    </xsl:call-template>, "<xsl:value-of select="@desc"/>", <xsl:choose>
                        <xsl:when test="@unique"><xsl:value-of select="@unique"/></xsl:when>
                        <xsl:otherwise>true</xsl:otherwise>
                    </xsl:choose>,
                        <xsl:value-of select="$ws"/><xsl:choose>
                        <xsl:when test="@default">variant(<xsl:call-template name="value-to-string">
                            <xsl:with-param name="value"><xsl:value-of select="@default"/></xsl:with-param>
                            <xsl:with-param name="type"><xsl:value-of select="@val_type"/></xsl:with-param>
                        </xsl:call-template>)</xsl:when>
                        <xsl:otherwise>variant()</xsl:otherwise></xsl:choose>, <xsl:choose>
                            <xsl:when test="@min">variant(<xsl:value-of select="@min"/>)</xsl:when>
                            <xsl:otherwise>variant()</xsl:otherwise>
                        </xsl:choose>, <xsl:choose>
                            <xsl:when test="@max">variant(<xsl:value-of select="@max"/>)</xsl:when>
                            <xsl:otherwise>variant()</xsl:otherwise>
                        </xsl:choose>, l_names, l_values, l_children<xsl:value-of select="$level"/>));
            <xsl:value-of select="$ws"/>}
            </xsl:for-each>
</xsl:template>

<xsl:template name="value-to-string">
    <xsl:param name="value"/>
    <xsl:param name="type"/>
    <xsl:choose>
        <xsl:when test="$type = 'string'">"<xsl:value-of select="$value"/>"</xsl:when>
        <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="string-to-type">
    <xsl:param name="type"/>
    <xsl:choose>
        <xsl:when test="$type = 'string'">STRING</xsl:when>
        <xsl:when test="$type = 'int'">INT</xsl:when>
        <xsl:when test="$type = 'bool'">BOOL</xsl:when>
        <xsl:when test="$type = 'float'">FLOAT</xsl:when>
        <xsl:when test="$type = 'anonymous'">ANONYMOUS</xsl:when>
        <xsl:otherwise>/* ERROR: undefined type <xsl:value-of select="$type"/> */</xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="pad">
    <xsl:param name="n" select="0"/>
    <xsl:if test="$n &gt; 0">
        <xsl:text>  </xsl:text>
        <xsl:call-template name="pad">
            <xsl:with-param name="n" select="number($n) - 1"/>
        </xsl:call-template>
    </xsl:if>
</xsl:template>

<xsl:template name="def-name">_AUTOGEN_<xsl:value-of
    select="translate(concat(@namespace, '_', @name),
	              'abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"
    />_HPP_</xsl:template>
        
</xsl:stylesheet>
