//----------------------------------------------------------------------------
/// \file  test_config_validator.cpp
//----------------------------------------------------------------------------
/// \brief Test cases for config_validator.
//----------------------------------------------------------------------------
// Copyright (c) 2012 Serge Aleynikov <saleyn@gmail.com>
// Created: 2012-01-14
//----------------------------------------------------------------------------
/*
***** BEGIN LICENSE BLOCK *****

This file may be included in different open-source projects.

Copyright (C) 2012 Serge Aleynikov <saleyn@gmail.com>

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

***** END LICENSE BLOCK *****
*/

#include <util/config_validator.hpp>
// The file below is auto-generated by running
// config_validator.xsl on test_config_validator.xml
#include "generated/test_config_validator.generated.hpp"

#ifndef NO_TEST_FRAMEWORK
#include <boost/test/unit_test.hpp>
#else
#include <boost/assert.hpp>
#define BOOST_AUTO_TEST_CASE(f) void f()
#define BOOST_REQUIRE(x) BOOST_ASSERT((x))
void BOOST_REQUIRE_EQUAL(const char* x, const char* y) {
    if (strcmp(x, y)) {
        std::cerr << "Left:  '" << (x) << "'\nRight: '" << (y) << "'" << std::endl;
        BOOST_ASSERT(false);
    }
}
void BOOST_REQUIRE_EQUAL(const char* x, const std::string& y) {
    if (y != x) {
        std::cerr << "Left:  '" << (x) << "'\nRight: '" << (y) << "'" << std::endl;
        BOOST_ASSERT(false);
    }
}

void test_config_validator1();
void test_config_validator2();
void test_config_validator3();
void test_config_validator4();
void test_config_validator5();
void test_config_validator6();
void test_config_validator7();
void test_config_validator8();

int main() {
    test_config_validator1();
    test_config_validator2();
    test_config_validator3();
    test_config_validator4();
    test_config_validator5();
    test_config_validator6();
    test_config_validator7();
    test_config_validator8();
    return 0;
}

#endif


using namespace util;

BOOST_AUTO_TEST_CASE( test_config_validator0 )
{
    test::cfg_validator l_validator;
    std::stringstream s;
    s << l_validator.usage("");
    BOOST_REQUIRE_EQUAL(
        "address: string\n"
        "  Description: Sample string entry\n"
        "      Default: \"123.124.125.012\"\n"
        "\n"
        "cost: float\n"
        "  Description: Sample float entry\n"
        "      Default: 1.5\n"
        "          Min: 0.0\n"
        "country: string\n"
        "  Description: Sample choice required entry\n"
        "       Unique: true\n"
        "     Required: true\n"
        "\n"
        "  connection (anonymous): string\n"
        "    Description: Server connection\n"
        "        Default: \"\"\n"
        "\n"
        "      address: string\n"
        "        Description: Server address\n"
        "           Required: true\n"
        "\n"
        "duration: int\n"
        "  Description: Sample required int entry\n"
        "     Required: true\n"
        "          Min: 10 Max: 60\n"
        "enabled: bool\n"
        "  Description: Sample bool entry\n"
        "      Default: true\n"
        "\n"
        "section: string\n"
        "     Required: true\n"
        "\n"
        "  location: int\n"
        "       Required: true\n"
        "\n"
        "section2: string\n"
        "\n"
        "  abc: string\n"
        "        Default: \"x\"\n"
        "\n",
        s.str());
}

BOOST_AUTO_TEST_CASE( test_config_validator1 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    l_stream
        << "address \"yahoo\"\n"
        << "enabled false\n"
        << "duration 20\n"
        << "cost     2.0\n"
        << "country \"US\"\n"
        << "  {\n"
        << "    ARCA\n"
        << "    { address \"1.2.3.4\" }\n"
        << "  }\n"
        << "section {\n"
        << "  location 10\n"
        << "}\n"
        << "country \"CA\"\n"
        << "  {\n"
        << "    ARCA exchange\n" /* This is an example of an anonymous
                                    node with value 'exchange' */
        << "    { address \"1.2.3.4\" }\n"
        << "    NSDQ\n"          /* Another anonymous node */
        << "    { address \"2.3.4.5\" }\n"
        << "  }\n";

    variant_tree::read_info(l_stream, l_config);

    try {
        test::cfg_validator l_validator;
        l_validator.validate(l_config, true);
        BOOST_REQUIRE(true); // Just to avoid a warning that there are no tests
    } catch (config_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator2 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    l_stream << "address \"yahoo\"\n";

    variant_tree::read_info(l_stream, l_config);

    test::cfg_validator l_validator;
    try {
        l_validator.validate(l_config, true);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country", e.path());
        BOOST_REQUIRE_EQUAL("Missing required option with no default!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator3 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    l_stream << "duration 10\n";

    variant_tree::read_info(l_stream, l_config);

    test::cfg_validator l_validator;
    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country", e.path());
        BOOST_REQUIRE_EQUAL("Missing required option with no default!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "country US { ARCA connection { address abc } }\nduration 10\n"
             << "section { location 10 }\n";

    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
    } catch (util::config_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "country US { }\nduration 10\n";

    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(true); // TODO: throw error because country.US.connection.address is undefined
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country[US]", e.path());
        BOOST_REQUIRE_EQUAL("Option is missing required child option connection.address", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator4 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    l_stream << "country US { ARCA connection { address abc } }\nduration 5\n"
             << "section { location 10 }\n";

    variant_tree::read_info(l_stream, l_config);

    test::cfg_validator l_validator;
    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("duration[5]", e.path());
        BOOST_REQUIRE_EQUAL("Value too small!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator5 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    l_stream << "country US { ARCA connection { address abc } }\nduration 61\n"
             << "section { location 10 }\n";

    variant_tree::read_info(l_stream, l_config);

    test::cfg_validator l_validator;
    try {
        l_validator.validate(l_config, true, "root");
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("root.duration[61]", e.path());
        BOOST_REQUIRE_EQUAL("Value too large!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator6 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    l_stream << "duration 10\n"
             << "country \"ER\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";

    variant_tree::read_info(l_stream, l_config);

    test::cfg_validator l_validator;
    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country[ER]", e.path());
        BOOST_REQUIRE_EQUAL("Value is not allowed for option!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator7 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    test::cfg_validator l_validator;

    l_stream << "duration 10\n"
             << "country \"US\"\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country[US]", e.path());
        BOOST_REQUIRE_EQUAL("Option is missing required child option connection.address", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n"
             << "country \"US\"\n"
             << "{\"ARCA\" example }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country[US].connection.ARCA[example].address", e.path());
        BOOST_REQUIRE_EQUAL("Missing required option with no default!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n"
             << "country \"ER\" { ARCA connection { address abc } }\n"
             << "abc test\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country[ER]", e.path());
        BOOST_REQUIRE_EQUAL("Value is not allowed for option!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "abc test\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("abc", e.path());
        BOOST_REQUIRE_EQUAL("Unsupported config option!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration 10\n country \"US\"\n { \"\" example }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("country[US].connection[example].address", e.path());
        BOOST_REQUIRE_EQUAL("Missing required option with no default!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "address abc\n address bcd\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("address[bcd]", e.path());
        BOOST_REQUIRE_EQUAL("Non-unique config option found!", e.what());
    }
}

BOOST_AUTO_TEST_CASE( test_config_validator8 )
{
    variant_tree l_config;
    std::stringstream l_stream;
    test::cfg_validator l_validator;

    l_stream << "address 10\nduration 15\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("address[10]", e.path());
        BOOST_REQUIRE_EQUAL("Wrong type - expected string!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "duration abc\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("duration[abc]", e.path());
        BOOST_REQUIRE_EQUAL("Wrong type - expected integer!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "enabled 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("enabled[1]", e.path());
        BOOST_REQUIRE_EQUAL("Wrong type - expected boolean true/false!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("cost[1]", e.path());
        BOOST_REQUIRE_EQUAL("Wrong type - expected float!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
        BOOST_REQUIRE(false);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("section", e.path());
        BOOST_REQUIRE_EQUAL("Missing required option with no default!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
    } catch (util::config_error& e) {
        BOOST_REQUIRE_EQUAL("cost[1]", e.path());
        BOOST_REQUIRE_EQUAL("Wrong type - expected float!", e.what());
    }

    l_config.clear();
    l_stream.clear();
    l_stream << "cost 1.0\n"
             << "duration 10\n"
             << "country \"US\" { ARCA connection { address abc } }\n"
             << "section { location 10 }\n";
    variant_tree::read_info(l_stream, l_config);

    try {
        l_validator.validate(l_config);
    } catch (util::config_error& e) {
        std::cerr << e.str() << std::endl;
        BOOST_REQUIRE(false);
    }

}

BOOST_AUTO_TEST_CASE( test_config_validator_def )
{
    test::cfg_validator l_validator;
    BOOST_REQUIRE_EQUAL(variant("123.124.125.012"), l_validator.default_value("test.address"));
    BOOST_REQUIRE_EQUAL(variant(true), l_validator.default_value("test.enabled"));
    BOOST_REQUIRE_EQUAL(variant(1.5), l_validator.default_value("test.cost"));
    BOOST_REQUIRE_EQUAL(variant("x"), l_validator.default_value("test.section2.abc"));
    BOOST_REQUIRE_THROW(l_validator.default_value("a.b.c"), util::config_error);

    config_tree l_config;
    bool b = l_validator.get<bool>("test.enabled", l_config);
    BOOST_REQUIRE(b);
}
